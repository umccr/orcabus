use crate::error::Error;
use crate::error::Error::DeserializeError;
use crate::error::Result;
use crate::events::aws::EventType::{Created, Deleted, Other};
use crate::events::aws::{FlatS3EventMessage, FlatS3EventMessages};
use chrono::{DateTime, ParseError, Utc};
use serde::{Deserialize, Serialize};
use uuid::Uuid;

#[derive(Debug, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EventMessage {
    EventBridge(Record),
    SQS(Message),
}

impl TryFrom<EventMessage> for FlatS3EventMessages {
    type Error = Error;

    fn try_from(message: EventMessage) -> Result<Self> {
        match message {
            EventMessage::EventBridge(record) => record.try_into(),
            EventMessage::SQS(message) => message.try_into(),
        }
    }
}

/// An S3 event message generated by an SQS queue or EventBridge. Serde rename and alias attributes
/// allow supporting both message types.
///
/// E.g.
/// https://docs.aws.amazon.com/AmazonS3/latest/userguide/notification-content-structure.html
/// https://docs.aws.amazon.com/AmazonS3/latest/userguide/ev-events.html
#[derive(Debug, Serialize, Deserialize, Eq, PartialEq)]
#[serde(rename_all = "kebab-case")]
pub struct Message {
    #[serde(alias = "Records")]
    pub records: Vec<Record>,
}

/// The inner record to for a message.
#[derive(Debug, Serialize, Deserialize, Eq, PartialEq)]
#[serde(rename_all = "kebab-case")]
pub struct Record {
    #[serde(alias = "eventTime")]
    pub time: String,
    #[serde(alias = "eventName")]
    pub detail_type: String,
    #[serde(alias = "s3")]
    pub detail: S3Record,
}

/// The detail of a message.
#[derive(Debug, Serialize, Deserialize, Eq, PartialEq)]
#[serde(rename_all = "kebab-case")]
pub struct S3Record {
    pub bucket: Bucket,
    pub object: Object,
}

/// The bucket name in a message.
#[derive(Debug, Serialize, Deserialize, Eq, PartialEq)]
#[serde(rename_all = "kebab-case")]
pub struct Bucket {
    pub name: String,
}

/// The object information of a message.
#[derive(Debug, Serialize, Deserialize, Eq, PartialEq)]
#[serde(rename_all = "kebab-case")]
pub struct Object {
    pub key: String,
    pub size: Option<i32>,
    #[serde(alias = "eTag")]
    pub etag: Option<String>,
    #[serde(alias = "versionId")]
    pub version_id: Option<String>,
    pub sequencer: Option<String>,
}

impl TryFrom<Record> for FlatS3EventMessages {
    type Error = Error;

    fn try_from(record: Record) -> Result<Self> {
        let Record {
            time,
            detail_type,
            detail,
        } = record;

        let S3Record { bucket, object } = detail;

        let Bucket { name: bucket } = bucket;

        let Object {
            key,
            size,
            etag,
            version_id,
            sequencer,
        } = object;

        let event_time: DateTime<Utc> = time
            .parse()
            .map_err(|err: ParseError| DeserializeError(err.to_string()))?;

        let event_type = if detail_type.contains("Object Created")
            || detail_type.contains("ObjectCreated")
        {
            Created
        } else if detail_type.contains("Object Removed") || detail_type.contains("ObjectRemoved") {
            Deleted
        } else {
            Other
        };

        Ok(FlatS3EventMessages(vec![FlatS3EventMessage {
            s3_object_id: Uuid::new_v4(),
            event_time: Some(event_time),
            bucket,
            key,
            size,
            e_tag: etag,
            sequencer,
            version_id,
            // Head fields are fetched later.
            storage_class: None,
            last_modified_date: None,
            event_type,
            number_reordered: 0,
            number_duplicate_events: 0,
        }]))
    }
}

impl TryFrom<Message> for FlatS3EventMessages {
    type Error = Error;

    fn try_from(message: Message) -> Result<Self> {
        Ok(FlatS3EventMessages(message.records.into_iter().try_fold(
            vec![],
            |mut flattened, record| {
                flattened.extend(FlatS3EventMessages::try_from(record)?.into_inner());
                Ok::<_, Self::Error>(flattened)
            },
        )?))
    }
}
