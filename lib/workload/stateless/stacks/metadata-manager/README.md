# Metadata Manager

One of the microservices in the OrcaBus that handles all the metadata information.

The metadata manager uses the Django framework.

## API

The API is deployed using a custom domain of `metadata` followed by the hosted name of the respective account
(`.dev.umccr.org`, `stg.umccr.org`). The hosted name can be retrieved from the SSM Parameter Store at
`/hosted_zone/umccr/name` from each account.
An example of the API endpoint is `https://metadata.umccr.org`.

The endpoint needs an authentication token which could be retrieved from the [token service
stack](../../../stateful/stacks/token-service/README.md). An example of retrieval is as follows.

```sh
export ORCABUS_TOKEN=$(aws secretsmanager get-secret-value --secret-id orcabus/token-service-jwt --output json --query SecretString | jq -r 'fromjson | .id_token')
```

The API currently supports the following paths:

- https://metadata.[STAGE].umccr.org/api/v1/library
- https://metadata.[STAGE].umccr.org/api/v1/specimen
- https://metadata.[STAGE].umccr.org/api/v1/subject

Stage means the environment where the API is deployed, it could be `dev`, `stg`, or `prod` (or omit this for prod).

An example of how to use a curl command to access the production API:

```sh
curl -s -H "Authorization: Bearer $ORCABUS_TOKEN" "https://metadata.umccr.org/api/v1/library" | jq
```

Filtering of results is also supported by the API. For example, to filter by `libraryId`, append the query parameter
to the URL: `.../library?libraryId=LIB001`

## Schema

This is the current (WIP) schema that reflects the current implementation. The schema is based on the
draft [draw.io in Google Drive](https://app.diagrams.net/#G10ryWSXORMo7Qj7ghvj37LHYqmMm4hXW-#%7B%22pageId%22%3A%22vfe626awnvWGlhOGvxTV%22%7D)
.

![schema](docs/schema.drawio.svg)

To modify the diagram, open the `docs/schema.drawio.svg` with [diagrams.net](https://app.diagrams.net/?src=about).

The `orcabus_id` serves as the unique identifier for each record in the database. It is generated by the application
using the [ULID](https://pypi.org/project/ulid-py/) library. When a record is accessed via the API, the `orcabus_id`
is presented with a prefix consisting of three characters followed by a dot (.). The specific prefix varies depending
on the model of the record.

| Model      | Prefix |
|------------|--------|
| Subject    | `sbj.` |
| Sample     | `smp.` |
| Library    | `lib.` |
| Individual | `idv.` |
| Contact    | `ctc.` |
| Project    | `prj.` |

## How things work

The metadata loader currently supports two Lambda functions: one for syncing from a tracking sheet and another for syncing from a custom CSV presigned URL. Upon a CREATE or UPDATE operation in the metadata library, the Lambda function will publish events to the `MainOrcabusEventBus` using the schema defined in [MetadataStateChange.schema.json](/docs/schemas/events/metadatamanager/MetadataStateChange.schema.json).

The event data will adhere to the same schema as the OpenAPI schema without nested object.

Example of the event emitted.

```json
{
  "version": "0",
  "id": "e7b8a2d4-3b6e-4f9b-9c1e-1a2b3c4d5e6f",
  "detail-type": "MetadataStateChange",
  "source": "orcabus.metadatamanager",
  "account": "12345678",
  "time": "2000-09-01T00:00:00Z",
  "region": "ap-southeast-2",
  "resources": [],
  "detail": {
    "action": "CREATE",
    "model": "LIBRARY",
    "refId": "lib.01J8GMF3XCHW9CV8ZFS8F1P1RF",
    "data": {
      "orcabusId": "lib.01J8GMF3XCHW9CV8ZFS8F1P1RF",
      "libraryId": "L10001",
      "phenotype": "normal",
      "workflow": "research",
      "quality": "good",
      "type": "WTS",
      "assay": "ctTSO",
      "coverage": 120.0,
      "sample": "smp.01J8GMF3WD6TD5Y491EEBARYBE",
      "subject": "sbj.01J8GMF3VZRGYQG1GYDJC6E9MV"
    }
  }
}

```

### How Syncing The Data Works

In the near future, we might introduce different ways to load data into the application. For the time being, we are
loading data
from the Google tracking sheet and mapping it to its respective model as follows.

| Sheet Header      | Table        | Field Name         |
|-------------------|--------------|--------------------|
| SubjectID         | `Individual` | individual_id      |
| ExternalSubjectID | `Subject`    | subject_id         |
| SampleID          | `Sample`     | sample_id          |
| ExternalSampleID  | `Sample`     | external_sample_id |
| Source            | `Sample`     | source             |
| LibraryID         | `Library`    | library_id         |
| Phenotype         | `Library`    | phenotype          |
| Workflow          | `Library`    | workflow           |
| Quality           | `Library`    | quality            |
| Type              | `Library`    | type               |
| Coverage (X)      | `Library`    | coverage           |
| Assay             | `Library`    | assay              |
| ProjectName       | `Project`    | project_id         |
| ProjectOwner      | `Contact`    | contact_id         |

Some important notes of the sync:

1. The sync will only run from the current year.
2. The tracking sheet is the single source of truth for the current year. Any deletion or update to existing records
   will be applied based on their internal IDs (e.g. `library_id`, `subject_id`, etc. ). For the library
   model, the deletion will only occur based on the current year's prefix. For example, syncing the 2024 tracking
   sheet will only query libraries with `library_id` tarting with `L24` to determine whether to delete it.
3. `LibraryId` is treated as a unique value in the tracking sheet, so for any duplicated value will only recognize 
   the last appearance.
4. In cases where multiple records share the same unique identifier (such as SampleId), only the data from the most
   recent record is stored. For instance, if a SampleId appears twice with differing source values, only the values from
   the latter record will be retained.
5. The sync happens every night periodically. See `./deploy/README.md` for more info.

Please refer to the [tracking-sheet-service](proc/service/tracking_sheet_srv.py) implementation.

### Custom CSV File Loader

The application also supports loading data from a custom CSV file. The CSV file should have the following columns:

| Sheet Header         | Table        | Field Name         |
|----------------------|--------------|--------------------|
| Individual_id        | `Individual` | individual_id      |
| individual_id_source | `Individual` | subject_id         |
| subject_id           | `Subject`    | subject_id         |
| sample_id            | `Sample`     | sample_id          |
| external_sample_id   | `Sample`     | external_sample_id |
| source               | `Sample`     | source             |
| library_id           | `Library`    | library_id         |
| phenotype            | `Library`    | phenotype          |
| workflow             | `Library`    | workflow           |
| quality              | `Library`    | quality            |
| type                 | `Library`    | type               |
| coverage             | `Library`    | coverage           |
| assay                | `Library`    | assay              |
| project_name         | `Project`    | project_id         |
| project_owner        | `Contact`    | contact_id         |

The CSV file should be in a presigned URL format, where the loader will read and insert to the database.
To trigger the loader please look at `./deploy/README.md` for more info.

Please refer to the [load-csv-service](proc/service/load_csv_srv.py) implementation.

### Audit Data

The application is configured with [django-simple-history](https://django-simple-history.readthedocs.io/en/latest/)
so that each update to a particular record will have an audit trail. This extension will create an additional table
one-to-one with the original table with `historical` prefixing of the table name. The historical table will have
additional attributes that would indicate addition/update/deletion.

## Running Locally

Requirement:

- Python
- Docker

```bash
docker -v
Docker version 20.10.12, build e91ed5707e

python3 --version
Python 3.12.2
```

You would need to go to this microservice app directory from the root project

```bash
cd lib/workload/stateless/stacks/metadata-manager
```

### Setup

You would need to set up the Python environment (conda or venv)

```bash
conda create -n orcabus_mm python=3.12
conda activate orcabus_mm
```

or with venv as an alternative

```bash
python3 -mvenv .venv
source .venv/bin/activate
```

Before starting the app we need to install the dependencies

```bash
make install
```

### Load Data

To load existing data to the database, you could use the following command

```bash
make insert-data
```

If you have UMCCR dev credential, you could copy a psql dump file in the s3 bucket and restore it to the local database.

```bash
make s3-load
````

### Start

To start the application run the start command. This will run the server at `http://localhost:8000/`

```bash
make start
```

To insert some mock data to be inserted, run the following command while the server is running.

```bash
make insert-data
```

If you want a shortcut the combination of starting the server with loaded s3 data, you could use the following command.

```bash
make loaded-start
```

### Stop

To stop the running server, simply use the `make stop` command

### Testing

To run the test from scratch use `make test`, but if you want to test with a running database you could use `make suite`
.

### Development

#### Migrations

From time to time the model of the app will need to change and apply the migrations. The following command will create
the migration changes and apply the migration respectively.

```bash
make makemigrations
make migrate
```

#### SQL Queries

To quickly run raw sql queries to the database, `make psql` will log in to the psql server.

### Deployment

View the deployment docs [here](./deploy/README.md).
