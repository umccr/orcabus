//! This module is responsible for generating sea-orm entities based on the current development
//! database schema.
//!

use std::ffi::OsStr;
use std::fs::{read_dir, read_to_string, write};

use clap_builder::Parser;
use heck::AsPascalCase;
use prettyplease::unparse;
use quote::quote;
use sea_orm_cli::{run_generate_command, Cli, Commands};
use syn::__private::Span;
use syn::{parse_file, parse_quote, Ident, Item};

use crate::error::ErrorKind::EntityGeneration;
use crate::error::{Error, Result};
use crate::Config;

pub async fn generate_entities() -> Result<()> {
    let config = Config::load()?;

    let out_dir = config.out_dir;
    let command: &[&_] = &[
        "sea-orm-cli",
        "generate",
        "entity",
        "--with-serde",
        "both",
        "--enum-extra-derives",
        "strum::FromRepr, strum::EnumCount",
        "--model-extra-derives",
        "utoipa::ToSchema",
        "--enum-extra-attributes",
        "repr(u8)",
        "--enum-extra-derives",
        "utoipa::ToSchema",
        "-u",
        &config.database_url,
        "-o",
    ]
    .map(OsStr::new);

    let cli = Cli::parse_from([command, &[out_dir.as_os_str()]].concat());
    if let Commands::Generate { command } = cli.command {
        run_generate_command(command, true)
            .await
            .map_err(|err| Error::from(EntityGeneration(err.to_string())))?;
    } else {
        panic!("command must be generate");
    }

    let path = out_dir.join("mod.rs");
    let path = path.to_string_lossy();
    let generated_comment = "// Auto-generated by the filemanager build script. See filemanager-build/src/gen_entities.rs.";
    let generated = quote!(
        #[path = #path]
        pub mod entities;
    );

    let out_file = out_dir.join("generated.rs");
    write(out_file, format!("{}\n\n{}", generated_comment, generated))?;

    for path in read_dir(out_dir)? {
        let path = path?.path();
        let content = read_to_string(&path)?;

        let mut tokens = parse_file(&content).map_err(|err| EntityGeneration(err.to_string()))?;
        let stem = path.file_stem().ok_or_else(|| {
            EntityGeneration("expected file with name when generating entities".to_string())
        })?;
        let name = "File".to_string() + &AsPascalCase(stem.to_string_lossy()).to_string();

        tokens.items.iter_mut().for_each(|item| {
            if let Item::Struct(item_struct) = item {
                if item_struct.ident == Ident::new("Model", Span::call_site()) {
                    let use_path: Ident = Ident::new(&name, Span::call_site());
                    item_struct
                        .attrs
                        .push(parse_quote! { #[schema(as = #use_path)] });
                }
            }
        });

        write(path, unparse(&tokens))?;
    }

    Ok(())
}
