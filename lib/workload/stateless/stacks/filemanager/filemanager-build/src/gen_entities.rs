//! This module is responsible for generating sea-orm entities based on the current development
//! database schema.
//!

use crate::error::ErrorKind::EntityGeneration;
use crate::error::{Error, Result};
use clap_builder::Parser;
use quote::quote;
use sea_orm_cli::{run_generate_command, Cli, Commands};
use std::ffi::OsStr;
use std::path::Path;
use tokio::fs::write;

/// Generate sea-orm entities into the `OUT_DIR`. `generate_mod` controls whether an additional
/// `generated.rs` module file is created with can be used with `include!(concat!(env!("OUT_DIR"), "/generated.rs"));`
pub async fn generate_entities(
    out_dir: &Path,
    database_url: &str,
    generate_mod: bool,
) -> Result<()> {
    let command: &[&_] = &[
        "sea-orm-cli",
        "generate",
        "entity",
        "--with-serde",
        "both",
        "--enum-extra-derives",
        "strum::FromRepr, strum::EnumCount, sqlx::Type",
        "--model-extra-derives",
        "utoipa::ToSchema",
        "--model-extra-attributes",
        "serde(rename_all = \"camelCase\")",
        "--enum-extra-derives",
        "utoipa::ToSchema",
        "-u",
        database_url,
        "-o",
    ]
    .map(OsStr::new);

    let cli = Cli::parse_from([command, &[out_dir.as_os_str()]].concat());
    if let Commands::Generate { command } = cli.command {
        run_generate_command(command, true)
            .await
            .map_err(|err| Error::from(EntityGeneration(err.to_string())))?;
    } else {
        panic!("command must be generate");
    }

    if generate_mod {
        let path = out_dir.join("mod.rs");
        let path = path.to_string_lossy();
        let generated_comment = "// Auto-generated by the filemanager build script. See filemanager-build/src/gen_entities.rs.";
        let generated = quote!(
            #[path = #path]
            pub mod entities;
        );

        let out_file = out_dir.join("generated.rs");
        write(out_file, format!("{}\n\n{}", generated_comment, generated)).await?;
    }

    Ok(())
}
